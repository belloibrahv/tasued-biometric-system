// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ==================== USER MODELS ====================

model User {
  id                String        @id @default(uuid())
  matricNumber      String        @unique
  email             String        @unique
  firstName         String
  lastName          String
  otherNames        String?
  phoneNumber       String?
  dateOfBirth       DateTime?
  department        String?
  level             String?       // Store as string to preserve "100", "200", etc.
  profilePhoto      String?
  isActive          Boolean       @default(true)
  biometricEnrolled Boolean       @default(false)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  biometricData     BiometricData?
  qrCodes           QRCode[]
  accessLogs        AccessLog[]
  sessions          Session[]
  auditLogs         AuditLog[]
  lectureAttendance LectureAttendance[]
  serviceAccess     ServiceAccess[]
}

model Admin {
  id          String      @id @default(uuid())
  email       String      @unique
  fullName    String
  role        AdminRole   @default(OPERATOR)
  permissions String[]
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  auditLogs   AuditLog[]  @relation("AdminAuditLogs")
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  OPERATOR
}

// ==================== BIOMETRIC MODELS ====================

model BiometricData {
  id                  String    @id @default(uuid())
  userId              String    @unique
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fingerprintTemplate String?   // Encrypted template
  fingerprintQuality  Float?
  facialTemplate      String?   // Encrypted template
  facialQuality       Float?
  facialPhotos        String[]  // Array of photo URLs/paths
  enrolledAt          DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([userId])
}

// ==================== QR CODE MODELS ====================

model QRCode {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  code        String    @unique
  isActive    Boolean   @default(true)
  expiresAt   DateTime
  usedAt      DateTime?
  lastUsedAt  DateTime?
  usageCount  Int       @default(0)
  maxUses     Int       @default(1)
  createdAt   DateTime  @default(now())

  @@index([userId])
  @@index([code])
  @@index([expiresAt])
}

// ==================== SERVICE MODELS ====================

model Service {
  id                  String      @id @default(uuid())
  name                String
  slug                String      @unique
  description         String?
  icon                String?
  isActive            Boolean     @default(true)
  requiresBiometric   Boolean     @default(false)
  allowMultipleEntry  Boolean     @default(true)
  maxCapacity         Int?
  currentOccupancy    Int         @default(0)
  operatingHours      Json?       // { start: "08:00", end: "18:00", days: [1,2,3,4,5] }
  location            String?
  requiredPermissions String[]
  optionalPermissions String[]
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  // Relations
  accessLogs          AccessLog[]
  sessions            Session[]
  serviceAccess       ServiceAccess[]
}

// Track entry/exit for services
model ServiceAccess {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceId   String
  service     Service   @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  entryTime   DateTime  @default(now())
  exitTime    DateTime?
  method      VerificationMethod @default(QR_CODE)
  status      AccessStatus @default(SUCCESS)
  operatorId  String?
  notes       String?
  
  @@index([userId, serviceId])
  @@index([serviceId, entryTime])
  @@index([userId, exitTime])
}

// ==================== ACCESS & SESSION MODELS ====================

model AccessLog {
  id              String          @id @default(uuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceId       String?
  service         Service?        @relation(fields: [serviceId], references: [id])
  action          String
  status          AccessStatus    @default(SUCCESS)
  method          VerificationMethod?
  confidenceScore Float?
  location        String?
  deviceInfo      String?
  ipAddress       String?
  timestamp       DateTime        @default(now())
  metadata        Json?

  @@index([userId])
  @@index([serviceId])
  @@index([timestamp])
  @@index([status])
}

enum AccessStatus {
  SUCCESS
  FAILED
  PENDING
  ERROR
}

enum VerificationMethod {
  QR_CODE
  FINGERPRINT
  FACIAL
  MANUAL
  DASHBOARD_FETCH
  IRIS
}

model Session {
  id          String        @id @default(uuid())
  userId      String
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceId   String?
  service     Service?      @relation(fields: [serviceId], references: [id])
  startTime   DateTime      @default(now())
  endTime     DateTime?
  status      SessionStatus @default(ACTIVE)
  ipAddress   String?
  userAgent   String?

  @@index([userId, status])
  @@index([serviceId])
}

enum SessionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

// ==================== AUDIT MODELS ====================

model AuditLog {
  id          String    @id @default(uuid())
  userId      String?
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  adminId     String?
  admin       Admin?    @relation("AdminAuditLogs", fields: [adminId], references: [id], onDelete: SetNull)
  actionType  String
  resourceType String?
  resourceId  String?
  oldValues   Json?
  newValues   Json?
  status      String?
  details     Json?
  ipAddress   String?
  userAgent   String?
  timestamp   DateTime  @default(now())

  @@index([userId, timestamp])
  @@index([adminId, timestamp])
  @@index([actionType])
  @@index([resourceType, resourceId])
}

// ==================== SYSTEM CONFIG ====================

model SystemConfig {
  id          String    @id @default(uuid())
  configKey   String    @unique
  configValue String?
  description String?
  updatedAt   DateTime  @default(now())
  updatedBy   String?

  @@index([configKey])
}

// ==================== LECTURE & ATTENDANCE MODELS ====================

model LectureSession {
  id          String    @id @default(uuid())
  courseCode  String
  courseName  String
  lecturer    String?
  venue       String
  startTime   DateTime
  endTime     DateTime
  department  String
  level       String
  isActive    Boolean   @default(true)
  createdBy   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  attendance  LectureAttendance[]

  @@index([courseCode])
  @@index([department, level])
  @@index([startTime, endTime])
}

model LectureAttendance {
  id                String              @id @default(uuid())
  lectureSessionId  String
  lectureSession    LectureSession      @relation(fields: [lectureSessionId], references: [id], onDelete: Cascade)
  userId            String
  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  method            VerificationMethod  @default(QR_CODE)
  status            VerificationStatus  @default(SUCCESS)
  checkInTime       DateTime            @default(now())
  checkOutTime      DateTime?
  matchScore        Float?
  location          String?
  deviceId          String?
  isLate            Boolean             @default(false)
  notes             String?
  createdAt         DateTime            @default(now())

  @@unique([lectureSessionId, userId])
  @@index([lectureSessionId])
  @@index([userId])
  @@index([checkInTime])
}

enum VerificationStatus {
  SUCCESS
  FAILED
  PENDING
}
